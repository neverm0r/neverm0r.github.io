<!DOCTYPE html>
<html><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <title>CVE-2022-0995: Heap overflow in watch_queue subsystem analysis and PoC - neverm0r&#39;s blog</title>

    
    
    <meta name="description" content="For the last few months, I have been shifting my interested from user space program to kernel space, which is harder and a lot more interesting since the exploit code is usually written in C (my favorite language to use :d). After doing some easy and old kernel pwning on pwnable.kr, I started to look at up-to-date kernel CTFs challenge. After feeling a bit comfortable with some modern techniques and was able to solve some CTFs kernel pwn, I decided to find an old bug and try to reproduce it." />
    <meta name="author" content="" />
    

    <link href="https://unpkg.com/@master/normal.css" rel="stylesheet">
    <script src="https://unpkg.com/@master/style@1.5.0"></script>
    <script src="https://unpkg.com/@master/styles@1.13.0"></script>
    <script src="https://unpkg.com/master-styles-group"></script>
    <script src="https://unpkg.com/themes.js"></script>
    <script>window.themes = window.themes || new window.Themes()</script>

    <style>
        :root {
            --font-sans: "Inter var", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;
        }
    </style></head>
<body class="bg:fade-84@dark font:fade-16@dark font:sans">
    <nav class="w:full h:90 fixed bg:fade-84/.95@dark bg:white z:1000">
    <div class="
        h:full
        w:full
        max-w:1200
        mx:auto
        px:32
        d:flex
        align-items:center
    ">
        <div>
            <a href="/" class="mr-3 font:extralight">
              
              neverm0r&#39;s blog
              
            </a>
        </div>

        <div class="ml:auto">
            
            
            
        </div>
    </div>
</nav>
<div class="d:flex flex:column@<=sm pt:90 px:24 jc:center gap:44 word-break:break-word">
        <div class="max-w:700 w:full box:content-box">
<article class="box:border-box pt:32">
    <header class="mb:32">
        <div class="font:40 font:extrabold">CVE-2022-0995: Heap overflow in watch_queue subsystem analysis and PoC</div>
        <div class="mt:16 f:fade-60">
            <time>Jul 14, 2023</time>
            </div>
    </header><div class="
    _:where(a):hover{text-decoration-color:fade}
    _:where(a){text-decoration:2;underline;fade-10;_text-decoration-color:fade-70@dark}
    _:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
    _:where(code){font:90%;_v:middle}
    _:where(code:not(.highlight_*,pre_*)){p:2;6;_r:4}
    _:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
    _:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
    _:where(h1){font:40;_font:extrabold}
    _:where(h1,h2,h3)+:where(h1,h2,h3){mt:.5em}
    _:where(h1,h2,h3,h4,h5,h6){mt:2em}
    _:where(h2){mb:1em;_font:32}
    _:where(h3){font:24}
    _:where(h4){font:20}
    _:where(h5){font:16}
    _:where(h6){font:14}
    _:where(li)::marker{font:fade-44;_font:fade-68@dark}
    _:where(li){pl:.375em}
    _:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
    _:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
    _:where(p,pre,blockquote,figure,ul,ol,table){my:1.125em}
    >:first-child{mt:0!}
    _:where(pre){p:20;_r:8;_overflow:auto}
    _:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
    _:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
    _:where(table){width:full;_border-spacing:0}
    _:where(td){v:baseline}
    _:where(td,th):first-child{pl:0}
    _:where(td,th):last-child{pr:0}
    _:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
    _:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
    _:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
    _:where(ul){list-style-type:disc}
    _:where(ul,ol,blockquote){pl:1.5em}
    _:where(video,img){max-width:full}
    _:where(a,mark){text-underline-offset:3}
    _:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:3em}
"><p>For the last few months, I have been shifting my interested from user space program to kernel space, which is harder and a lot more interesting since the exploit code is usually written in C (my favorite language to use :d). After doing some easy and old kernel pwning on <a href="http://pwnable.kr"><code>pwnable.kr</code></a>, I started to look at up-to-date kernel CTFs challenge. After feeling a bit comfortable with some modern techniques and was able to solve some CTFs kernel pwn, I decided to find an old bug and try to reproduce it. <code>CVE-2022-0995</code> was a good starter since it uses a well-known <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#escalating-privileges">technique</a> and the exploits is quite similar. Let&rsquo;s get into action</p>
<h2 id="1-background">1. Background:</h2>
<blockquote>
<p><a href="https://docs.kernel.org/core-api/watch_queue.html">https://docs.kernel.org/core-api/watch_queue.html</a></p>
</blockquote>
<p>For the full documentation on <code>watch_queue</code> and kernel notification mechanism, please refer to the ring above. I will only go through some structures and that is relevant to the exploit and the vulnerability.</p>
<p>From the documentation, <code>watch queue</code> is the buffer allocated by an application that notification records will be written into. The working is hidden entirely inside of the pipe device driver, but it is necessary to gain a reference to it to set a watch. These can be managed with:</p>
<ul>
<li><code>get_watch_queue(int fd)</code>: use to look up an opaque pointer to the watch queue from the system call.</li>
<li><code>put_watch_queue(struct watch_queue *wqueue)</code>: Discard the references obtained from <code>get_watch_queue</code></li>
</ul>
<p>After a <code>watch queue</code> has been created, a set of filters can be applied to limit the events that are received using <code>ioctl</code> call:</p>
<pre tabindex="0"><code>struct watch_notification_filter filter = {
        ...
};
ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)
</code></pre><p>The <code>struct watch_notification_filter</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> watch_notification_filter {
</span></span><span style="display:flex;"><span>        __u32   nr_filters;
</span></span><span style="display:flex;"><span>        __u32   __reserved;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> watch_notification_type_filter filters[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><code>nr_filters</code> are the number of filters that the user can supply for <code>filters[]</code> and <code>__reserved</code> should be 0.</p>
<p>The <code>filters</code> array has elements of following type:</p>
<pre tabindex="0"><code>struct watch_notification_type_filter {
        __u32   type;
        __u32   info_filter;
        __u32   info_mask;
        __u32   subtype_filter[8];
};
</code></pre><h3 id="2-vulnerability-analysis">2. Vulnerability analysis:</h3>
<p>First, let&rsquo;s take a look at the description of the bug:</p>
<blockquote>
<p>An out-of-bounds (OOB) memory write flaw was found in the Linux kernelâ€™s watch_queue event notification subsystem. This flaw can overwrite parts of the kernel state, potentially allowing a local user to gain privileged access or cause a denial of service on the system.</p>
</blockquote>
<p>Then the patch <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb</a>:</p>
<pre tabindex="0"><code>@ -320,7 +319,7 @@ long watch_queue_set_filter(struct pipe_inode_info *pipe,
 		    tf[i].info_mask &amp; WATCH_INFO_LENGTH)
 			goto err_filter;
 		/* Ignore any unknown types */
-		if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)
+		if (tf[i].type &gt;= WATCH_TYPE__NR)
 			continue;
 		nr_filter++;
 	}
@@ -336,7 +335,7 @@ long watch_queue_set_filter(struct pipe_inode_info *pipe,
 
 	q = wfilter-&gt;filters;
 	for (i = 0; i &lt; filter.nr_filters; i++) {
-		if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)
+		if (tf[i].type &gt;= WATCH_TYPE__NR)
 			continue;
 
 		q-&gt;type			= tf[i].type;
</code></pre><p>The bug lies in the function <code>watch_queue_set_filter</code>, occurs in the process of copying the filter array from user space to kernel. Call chain to reach vulnerable function:</p>
<blockquote>
<p><a href="https://elixir.bootlin.com/linux/v5.16.14/source/fs/ioctl.c#L874">ioctl</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.16.14/source/fs/ioctl.c#L51">vfs_ioctl()</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.16.14/source/fs/pipe.c#L636">pipe_ioctl()</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.16.14/source/kernel/watch_queue.c#L346">watch_queue_set_filter()</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.16.14/source/tools/include/asm-generic/bitops/non-atomic.h#L16">__set_bit()</a></p>
</blockquote>
<p>Let&rsquo;s analyze the function to understand what causes the vulnerability. First, it copies the <code>filter</code> from user space to kernel space:</p>
<pre tabindex="0"><code>long watch_queue_set_filter(struct pipe_inode_info *pipe,
			    struct watch_notification_filter __user *_filter)
{
	struct watch_notification_type_filter *tf;
	struct watch_notification_filter filter;
	struct watch_type_filter *q;
	struct watch_filter *wfilter;
	struct watch_queue *wqueue = pipe-&gt;watch_queue;
	int ret, nr_filter = 0, i;

	if (!wqueue)
		return -ENODEV;

	if (!_filter) {
		/* Remove the old filter */
		wfilter = NULL;
		goto set;
	}

	/* Grab the user&#39;s filter specification */
	if (copy_from_user(&amp;filter, _filter, sizeof(filter)) != 0)
		return -EFAULT;
	if (filter.nr_filters == 0 ||
	    filter.nr_filters &gt; 16 ||
	    filter.__reserved != 0)
		return -EINVAL;
</code></pre><p>After allocating temporary space, copy the user filter array to the temporary space:</p>
<pre tabindex="0"><code>tf = memdup_user(_filter-&gt;filters, filter.nr_filters * sizeof(*tf));
if (IS_ERR(tf))
	return PTR_ERR(tf);
</code></pre><p>Next, each filter is traversed, and check if the <code>type</code> of the filter is in a valid range. In this case, valid range is <strong>sizeof</strong>(wfilter-&gt;type_filter) * 8 = 0x80:</p>
<pre tabindex="0"><code>ret = -EINVAL;
for (i = 0; i &lt; filter.nr_filters; i++) {
	if ((tf[i].info_filter &amp; ~tf[i].info_mask) ||
	    tf[i].info_mask &amp; WATCH_INFO_LENGTH)
		goto err_filter;
	/* Ignore any unknown types */
	if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)
		continue;
	nr_filter++;
}
</code></pre><p>Then it will allocate space to store the filter using <code>kzalloc</code>, with size base on the number of filter used:</p>
<pre tabindex="0"><code>/* Now we need to build the internal filter from only the relevant
 * user-specified filters.
 */
ret = -ENOMEM;
wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);
if (!wfilter)
	goto err_filter;
wfilter-&gt;nr_filters = nr_filte
</code></pre><p>After that, the filter array is copied into the allocated space and this is where the vulnerability occur. Here it checks if <code>type</code> is in valid range but it is inconsistent with the previous check:</p>
<pre tabindex="0"><code>q = wfilter-&gt;filters;
	for (i = 0; i &lt; filter.nr_filters; i++) { 				
		if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)
			continue;

		q-&gt;type				= tf[i].type;						
		q-&gt;info_filter		= tf[i].info_filter;
		q-&gt;info_mask		= tf[i].info_mask;
		q-&gt;subtype_filter[0]	= tf[i].subtype_filter[0];
		__set_bit(q-&gt;type, wfilter-&gt;type_filter);			
		q++;
	}
</code></pre><p>The above compares <code>type</code> with  0x80, however in this check, it checks if <code>type</code> with <code>sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG</code>, which is 0x400. So if we make a filter that has type in range <code>[0x80, 0x400) </code>, the number of filters are actually larger than intended. The function then call <code>__set_bit</code> , which can cause a 1-bit out of bound write on <code>q-&gt;type</code>. This is the vulnerability.</p>
<h3 id="3-exploit-strategy">3. Exploit strategy</h3>
<p>From the original <a href="https://github.com/Bonfee/CVE-2022-0995">exploit</a>, the author uses the same technique as in <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html"><code>CVE-2021-22555</code></a>. I suggest you to read it and also <a href="https://syst3mfailure.io/wall-of-perdition/">this</a> to understand more about it.</p>
<p>Using the author suggestion, we can immediately come up with a strategy:</p>
<ul>
<li>
<p>Create 4096 message queue, with primary message and secondary message fall into<code>kmalloc-96</code> and <code>kmalloc-1024</code> respectively.</p>
</li>
<li>
<p>Create 4 holes in the primary message: 0/1024/2048/3072. Then trigger the 1-bit out-of-bound by creating 4 filters, 3 filters with valid type and 1 filter with type falls in range <code>[0x80, 0x400)</code>. This will make <code>wfilter</code> falls into <code>kmalloc-96</code>, same with the primary message. In this case, the invalid filter will have <code>type</code> = 0x30a, since 0x60 * 8 = 0x300, 0xa will tamper with <code>m_list_next</code>.</p>
</li>
<li>
<p>The 1-bit out of bound can modify 1 bit of the  message <code>m_list_next</code>, create a possibility of 2 messages point to a same message. By releasing main message, we have now achieved UAF scenario. We mark the release one as <code>real_qid</code> and the modified one with <code>victim_qid</code></p>
</li>
<li>
<ul>
<li>
<p>Spray <code>sk_buff</code> to occupy the <code>real_qid</code> message and and forge <code>victim_qid</code> message <code>m_ts</code>= 0xfd0.</p>
</li>
<li>
<p>Use <code>victim_qid</code> message to OOB read and leak <code>msg_msg-&gt;m_list_prev</code>, we call this <code>prev_msg</code></p>
</li>
<li>
<p>Spray <code>sk_buff</code> again after free, forge <code>msg_msg-&gt;m_ts</code> = 0x1fc8 (0x1000 - sizeof(msg_msg) + 0x1000 - sizeof(msg_msg_seg)).</p>
</li>
<li>
<p>Leak <code>msg_msg-&gt;m_list_next</code>, we call this <code>next_msg</code></p>
</li>
</ul>
</li>
<li>
<p>Bypass KASLR:</p>
<ul>
<li>Free <code>sk_buff</code>, then we spray a fake <code>msg_msg</code>, make <code>m_list_next</code> a valid heap memory, in my exploit it is <code>victim_qid</code> + 0x800</li>
<li>Free <code>victim_qid</code>, then spray <code>pipe_buffer</code> to reclaim the <code>sk_buff</code> data buffer.</li>
<li>Since we still have a reference for <code>struct sk_buff</code>, we can read its data buffer, and leak <code>pipe_buffer-&gt;ops</code>, bypassing KASLR</li>
</ul>
</li>
<li>
<p>Hijack RIP and get shell :dark_sunglasses: :</p>
</li>
</ul>
<pre><code>*   Reclaim `pipe_buffer` with a fake one with `ops` pointing to a fake `struct pipe_buf_operations`. This `ops` is used as a pivot gadget, pivot us back to our ROP chain. When `release` is called, the ROP chain will be executed and we will get a shell :d 
</code></pre>
<p>However, this exploit is not 100% reliable, you might need to run it a few times. PoC can be found <a href="https://github.com/neverm0r/Kernel_exploit/blob/main/CVE-2022-0995/exploit.c">here</a>. The results:</p>
<pre tabindex="0"><code>/ $ id
uid=1000(chal) gid=1000(chal) groups=1000(chal)
/ $ ls -al | grep flag
-rw-------    1 root     root            22 Jul 16 17:00 flag\
/ $ ./exploit 
[*] CVE-2022-0995
[*] Set to specific core
[*] State saved.
[*] Create 4096 queue
[*] Spraying primary message
[*] Spraying secondary messsage
[*] Create holes in message to later construct UAF
[*] Trigger out of bound bug and check if we create the message overlapping or not
[*] OOB triggered
[*] real_qid: 0xfec
[*] victim_qid: 0xfee
[*] Freeing secondary message to construct UAF
[*] Spraying fake secondary message
[*] OOB read from victim msg_msg
[*] Primary message: 0xffff888005e57600
[*] Arbitrary read using oob_msg
[*] UAF object addr: 0xffff8880060aa400
[*] Now we spray pipe_buffer to leak kernel address
[*] pipe_buffer spraying...
[*] Free sk_buff to read pipe_buffer
[*] anon_pipe_buf_ops: 0xffffffff8223e140
[*] Kernel base: 0xffffffff81000000
[*] Now we hijack the ops of pipe_buffer, gain code execution
[*] Spraying sk_buff to hijack pipe_buffer
[*] Trigger fake ops-&gt;release to execute ROP chain
[*] Success! Pop root shell
/ # id
uid=0(root) gid=0(root)
</code></pre><p>But this exploit  can only work on kernel version before 5.14 since after that, <code>msg_msg</code> falls in to <code>kmalloc-cg-*</code> cache, not general cache anymore, makes it more difficult to exploit this bug. I might try to exploit it in later version after this.</p>
<h3 id="4-conclusion">4. Conclusion:</h3>
<p>Trying to reproduce this bug for me was a small success to me. Even though the exploit is quite similar but being able to reproduce it from scratch, and start audit some small linux kernel code was a good experience.  Hopefully in the future, I can reproduce more difficult bugs and if more find a 0-day :d.</p>
<h3 id="reference">Reference:</h3>
<ul>
<li><a href="https://docs.kernel.org/core-api/watch_queue.html"><em>General notify mechanism</em></a></li>
<li><a href="https://github.com/Bonfee/CVE-2022-0995">https://github.com/Bonfee/CVE-2022-0995</a></li>
<li><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">CVE-2021-22555: Turning \x00\x00 into 10000$</a></li>
<li><a href="https://syst3mfailure.io/wall-of-perdition/">corCTF 2021-Wall Of Perdition: Utilizing msg_msg Objects For Arbitrary Read And Arbitrary Write In The Linux Kernel (syst3mfailure.io)</a></li>
</ul>
</div></article>
<footer class="py:24">
    <div class="f:fade-30 f:14 mb:8"></div>
    <div class="f:fade-60 f:12">Theme <a class="f:bold" href="https://github.com/serkodev/holy" _target="_blank">Holy</a></div>
</footer></div>
    </div>
</body>

</html>